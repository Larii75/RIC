///Copyright (c) 2021, https://github.com/Larii75 Linchenko Andrii
///
///Разрешается повторное распространение и использование как в виде исходного кода, так и в двоичной форме, с изменениями или без, при соблюдении следующих условий:
///
///При повторном распространении исходного кода должно оставаться указанное выше уведомление об авторском праве, этот список условий и последующий отказ от гарантий.
///При повторном распространении двоичного кода должна сохраняться указанная выше информация об авторском праве, этот список условий и последующий отказ от гарантий 
///в документации и/или в других материалах, поставляемых при распространении. 
///Ни название <Организации>, ни имена её сотрудников не могут быть использованы в качестве поддержки или продвижения продуктов, основанных на этом ПО без предварительного письменного разрешения.
///ЭТА ПРОГРАММА ПРЕДОСТАВЛЕНА ВЛАДЕЛЬЦАМИ АВТОРСКИХ ПРАВ И/ИЛИ ДРУГИМИ СТОРОНАМИ «КАК ОНА ЕСТЬ» БЕЗ КАКОГО-ЛИБО ВИДА ГАРАНТИЙ, ВЫРАЖЕННЫХ ЯВНО ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ, 
///ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ КОММЕРЧЕСКОЙ ЦЕННОСТИ И ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ. 
///НИ В КОЕМ СЛУЧАЕ НИ ОДИН ВЛАДЕЛЕЦ АВТОРСКИХ ПРАВ И НИ ОДНО ДРУГОЕ ЛИЦО, КОТОРОЕ МОЖЕТ ИЗМЕНЯТЬ И/ИЛИ ПОВТОРНО РАСПРОСТРАНЯТЬ ПРОГРАММУ, КАК БЫЛО СКАЗАНО ВЫШЕ, НЕ НЕСЁТ ОТВЕТСТВЕННОСТИ,
///ВКЛЮЧАЯ ЛЮБЫЕ ОБЩИЕ, СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ ИЛИ ПОСЛЕДОВАВШИЕ УБЫТКИ, ВСЛЕДСТВИЕ ИСПОЛЬЗОВАНИЯ ИЛИ НЕВОЗМОЖНОСТИ ИСПОЛЬЗОВАНИЯ ПРОГРАММЫ 
///(ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ПОТЕРЕЙ ДАННЫХ, ИЛИ ДАННЫМИ, СТАВШИМИ НЕПРАВИЛЬНЫМИ, ИЛИ ПОТЕРЯМИ, ПРИНЕСЕННЫМИ ИЗ-ЗА ВАС ИЛИ ТРЕТЬИХ ЛИЦ, 
///ИЛИ ОТКАЗОМ ПРОГРАММЫ РАБОТАТЬ СОВМЕСТНО С ДРУГИМИ ПРОГРАММАМИ), ДАЖЕ ЕСЛИ ТАКОЙ ВЛАДЕЛЕЦ ИЛИ ДРУГОЕ ЛИЦО БЫЛИ ИЗВЕЩЕНЫ О ВОЗМОЖНОСТИ ТАКИХ УБЫТКОВ.
///
///Copyright (c) 2021, https://github.com/Larii75 Linchenko Andrii All rights reserved.
///
///Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
///
///Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
///Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
///Neither the name of the <ORGANIZATION> nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
///THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
///THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER 
///OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
///PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
///LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
///EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

///Список работ далее:
///
///*Оставлять Структуру.ИЛИ (если есть элементы в массиве) в основной последовательности, но вычислять приоритет между ним и литералом
///*Доработать механизм ошибок по метасимволам
///...
///*ветвления(|)
///*группы(captures), циклы(замыкания, квесты, плюсы, звезды), начало/конец строки, 
///конец/начало слов, lookaround, backreference, именованные группы, доделать флаги. 
///...
///*Replace(), Test(), а не только Μatches(). Модификаторы результатов $' $` $&
///...
//ToDo \1 - backreference to group #1
//ToDo \p{L} \p{Han} - категории и скрипты unicode
//ToDo \251 - код символа в восьмиричной
//ToDo \xFF - код символа в шестнадцатиричной
//ToDo \uFFFF - код символа в Unicode
//ToDo \u{FFFF} - код символа в Unicode расширенный вариант
//ToDo \c - код символа комбинаций ctrl (\cI matches TAB (char code 9)
///
///Пример по коллизии подходов NFA w/o backtrack(когда паттерн - команды для автомата, которые выполняются слева-направо) и DFA(когда паттерн - просто маска, которая сверяется со строкой)
///Паттерн "([01]*)*1"
///Строка "01000000000000000000000"
///по NFA w/o backtrack - no match
///по DFA - "01"

#Область Версия_0_6

// Функция - Проверить символ
//
// Параметры:
//  Символ	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
&НаКлиентеНаСервереБезКонтекста
Функция ПроверитьСимвол(Символ)
	
	///Маловероятно, но мир полон чудес.
	Результат = КодСимвола(Символ);
	Возврат Результат > -1;

КонецФункции // ПроверитьСимвол()

// Функция - Вернуть структуру констант РІС
// 
// Возвращаемое значение:
//   - 
//
&НаКлиентеНаСервереБезКонтекста
Функция ВернутьСтруктуруКонстантРІС()
	
	dPerl = Новый Массив; /// \d
	dPerl.Добавить(48); 
	dPerl.Добавить(57);
	dPerl = Новый ФиксированныйМассив(dPerl);

	sPerl = Новый Массив; /// \s
	sPerl.Добавить(9); 
	sPerl.Добавить(10);
	sPerl.Добавить(12); 
	sPerl.Добавить(13);
	sPerl.Добавить(32);
	sPerl.Добавить(32);
	sPerl = Новый ФиксированныйМассив(sPerl);
	///спёрл :)

	wPerl = Новый Массив; /// \w
	wPerl.Добавить(48); 
	wPerl.Добавить(57);
	wPerl.Добавить(65); 
	wPerl.Добавить(90);
	wPerl.Добавить(97); 
	wPerl.Добавить(122);
	wPerl.Добавить(95); 
	wPerl.Добавить(95);
	wPerl = Новый ФиксированныйМассив(wPerl);
	
	AlnumPOSIX = Новый Массив; /// [:alnum:]
	AlnumPOSIX.Добавить(48); 
	AlnumPOSIX.Добавить(57);
	AlnumPOSIX.Добавить(65); 
	AlnumPOSIX.Добавить(90);
	AlnumPOSIX.Добавить(97); 
	AlnumPOSIX.Добавить(122);
	AlnumPOSIX = Новый ФиксированныйМассив(AlnumPOSIX);

	AlphaPOSIX = Новый Массив; /// [:alpha:]
	AlphaPOSIX.Добавить(65); 
	AlphaPOSIX.Добавить(90);
	AlphaPOSIX.Добавить(97); 
	AlphaPOSIX.Добавить(122);
	AlphaPOSIX = Новый ФиксированныйМассив(AlphaPOSIX);

	AsciiPOSIX = Новый Массив; /// [:ascii:]
	AsciiPOSIX.Добавить(0); 
	AsciiPOSIX.Добавить(127);
	AsciiPOSIX = Новый ФиксированныйМассив(AsciiPOSIX);

	BlankPOSIX = Новый Массив; /// [:blank:]
	BlankPOSIX.Добавить(9); 
	BlankPOSIX.Добавить(9);
	BlankPOSIX.Добавить(32); 
	BlankPOSIX.Добавить(32);
	BlankPOSIX = Новый ФиксированныйМассив(BlankPOSIX);

	CntrlPOSIX = Новый Массив; /// [:cntrl:]
	CntrlPOSIX.Добавить(0); 
	CntrlPOSIX.Добавить(31);
	CntrlPOSIX.Добавить(127); 
	CntrlPOSIX.Добавить(127);
	CntrlPOSIX = Новый ФиксированныйМассив(CntrlPOSIX);

	DigitPOSIX = Новый Массив; /// [:digit:]
	DigitPOSIX.Добавить(48); 
	DigitPOSIX.Добавить(57);
	DigitPOSIX = Новый ФиксированныйМассив(DigitPOSIX);

	GraphPOSIX = Новый Массив; /// [:graph:]
	GraphPOSIX.Добавить(33); 
	GraphPOSIX.Добавить(126);
	GraphPOSIX = Новый ФиксированныйМассив(GraphPOSIX);

	LowerPOSIX = Новый Массив; /// [:lower:]
	LowerPOSIX.Добавить(97); 
	LowerPOSIX.Добавить(122);
	LowerPOSIX = Новый ФиксированныйМассив(LowerPOSIX);

	PrintPOSIX = Новый Массив; /// [:print:]
	PrintPOSIX.Добавить(32); 
	PrintPOSIX.Добавить(126);
	PrintPOSIX = Новый ФиксированныйМассив(PrintPOSIX);

	PunctPOSIX = Новый Массив; /// [:punct:]
	PunctPOSIX.Добавить(33); 
	PunctPOSIX.Добавить(47);
	PunctPOSIX.Добавить(58); 
	PunctPOSIX.Добавить(64);
	PunctPOSIX.Добавить(91); 
	PunctPOSIX.Добавить(96);
	PunctPOSIX.Добавить(123); 
	PunctPOSIX.Добавить(126);
	PunctPOSIX = Новый ФиксированныйМассив(PunctPOSIX);

	SpacePOSIX = Новый Массив; /// [:space:]
	SpacePOSIX.Добавить(9); 
	SpacePOSIX.Добавить(13);
	SpacePOSIX.Добавить(32); 
	SpacePOSIX.Добавить(32);
	SpacePOSIX = Новый ФиксированныйМассив(SpacePOSIX);

	UpperPOSIX = Новый Массив; /// [:upper:]
	UpperPOSIX.Добавить(65); 
	UpperPOSIX.Добавить(90);
	UpperPOSIX = Новый ФиксированныйМассив(UpperPOSIX);

	WordPOSIX = Новый Массив; /// [:word:]
	WordPOSIX.Добавить(48); 
	WordPOSIX.Добавить(57);
	WordPOSIX.Добавить(65); 
	WordPOSIX.Добавить(90);
	WordPOSIX.Добавить(95); 
	WordPOSIX.Добавить(95);
	WordPOSIX.Добавить(97); 
	WordPOSIX.Добавить(122);
	WordPOSIX = Новый ФиксированныйМассив(WordPOSIX);

	XdigitPOSIX = Новый Массив; /// [:xdigit:]
	XdigitPOSIX.Добавить(48);
	XdigitPOSIX.Добавить(57);
	XdigitPOSIX.Добавить(65); 
	XdigitPOSIX.Добавить(70);
	XdigitPOSIX.Добавить(97); 
	XdigitPOSIX.Добавить(102);
	XdigitPOSIX = Новый ФиксированныйМассив(XdigitPOSIX);
	
	СтруктураДиапазонов = Новый Структура;
	СтруктураДиапазонов.Вставить("dPerl", dPerl);
	СтруктураДиапазонов.Вставить("sPerl", sPerl);
	СтруктураДиапазонов.Вставить("wPerl", wPerl);
	СтруктураДиапазонов.Вставить("AlnumPOSIX", AlnumPOSIX);
	СтруктураДиапазонов.Вставить("AlphaPOSIX", AlphaPOSIX);
	СтруктураДиапазонов.Вставить("AsciiPOSIX", AsciiPOSIX);
	СтруктураДиапазонов.Вставить("BlankPOSIX", BlankPOSIX);
	СтруктураДиапазонов.Вставить("CntrlPOSIX", CntrlPOSIX);
	СтруктураДиапазонов.Вставить("DigitPOSIX", DigitPOSIX);
	СтруктураДиапазонов.Вставить("GraphPOSIX", GraphPOSIX);
	СтруктураДиапазонов.Вставить("LowerPOSIX", LowerPOSIX);
	СтруктураДиапазонов.Вставить("PrintPOSIX", PrintPOSIX);
	СтруктураДиапазонов.Вставить("PunctPOSIX", PunctPOSIX);
	СтруктураДиапазонов.Вставить("SpacePOSIX", SpacePOSIX);
	СтруктураДиапазонов.Вставить("UpperPOSIX", UpperPOSIX);
	СтруктураДиапазонов.Вставить("WordPOSIX", WordPOSIX);
	СтруктураДиапазонов.Вставить("XdigitPOSIX", XdigitPOSIX);
	СтруктураДиапазонов = Новый ФиксированнаяСтруктура(СтруктураДиапазонов);
	
	///Терминаторы строки для Инструкции 2
	///Карта не полная...
	КартаТерминаторовСтроки = Новый Соответствие;
	КартаТерминаторовСтроки.Вставить(Символы.ПС, Истина);
	КартаТерминаторовСтроки.Вставить(Символы.ВК, Истина);
	КартаТерминаторовСтроки.Вставить(Символ(133), Истина);
	КартаТерминаторовСтроки.Вставить(Символ(8232), Истина);
	КартаТерминаторовСтроки.Вставить(Символ(8233), Истина);
	///КартаТерминаторовСтроки = Новый ФиксированноеСоответствие(КартаТерминаторовСтроки); ///Нужно именно соответствие
		
	КартаМетаСимволовКодам = Новый Соответствие;
	КартаМетаСимволовКодам.Вставить("/", 0); //СтартФиниш
	КартаМетаСимволовКодам.Вставить("\", 1); //Экран
	КартаМетаСимволовКодам.Вставить(".", 2); //Любой символ, кроме терминаторов
	КартаМетаСимволовКодам.Вставить("+", 3); //Один или больше
	КартаМетаСимволовКодам.Вставить("*", 4); //Ноль или больше
	КартаМетаСимволовКодам.Вставить("?", 5); //Ноль или один
	КартаМетаСимволовКодам.Вставить("(", 6); //Группа старт
	КартаМетаСимволовКодам.Вставить(")", 7); //Группа финиш
	КартаМетаСимволовКодам.Вставить("|", 8); //ИЛИ
	КартаМетаСимволовКодам.Вставить("]", 9); //Группа ИЛИ старт
	КартаМетаСимволовКодам.Вставить("[", 10); //Группа ИЛИ финиш
	КартаМетаСимволовКодам.Вставить("}", 11); //Группа циклов старт
	КартаМетаСимволовКодам.Вставить("{", 12); //Группа циклов финиш
	КартаМетаСимволовКодам.Вставить("^", 13); //В начале строки
	КартаМетаСимволовКодам.Вставить("$", 14); //В конце строки
	КартаМетаСимволовКодам = Новый ФиксированноеСоответствие(КартаМетаСимволовКодам);
	
	//ToDo \1 - backreference to group #1
	//ToDo \p{L} \p{Han} - категории и скрипты unicode
	//ToDo \251 - код символа в восьмиричной
	//ToDo \xFF - код символа в шестнадцатиричной
	//ToDo \uFFFF - код символа в Unicode
	//ToDo \u{FFFF} - код символа в Unicode расширенный вариант
	//ToDo \c - код символа комбинаций ctrl (\cI matches TAB (char code 9))	
	КартаЭкранированных = Новый Соответствие;  
	КартаЭкранированных.Вставить("", Неопределено); /// маркер ошибки
	КартаЭкранированных.Вставить(1, Неопределено);  /// маркер ошибки
	КартаЭкранированных.Вставить("w", 15); //диапазон
	КартаЭкранированных.Вставить("d", 16); //диапазон
	КартаЭкранированных.Вставить("s", 17); //диапазон
	КартаЭкранированных.Вставить("W", 18); //диапазон
	КартаЭкранированных.Вставить("D", 19); //диапазон
	КартаЭкранированных.Вставить("S", 20); //диапазон
	КартаЭкранированных.Вставить("b", 21); //ToDo
	КартаЭкранированных.Вставить("B", 22); //ToDo
	КартаЭкранированных.Вставить("t", Символы.Таб);
	КартаЭкранированных.Вставить("n", Символы.ПС);
	КартаЭкранированных.Вставить("r", Символы.ВК);
	КартаЭкранированных.Вставить("v", Символы.ВТаб);
	КартаЭкранированных.Вставить("f", Символы.ПФ);
	КартаЭкранированных.Вставить("a", Символ(7));  //bell
	КартаЭкранированных.Вставить("e", Символ(27)); //escape
	КартаЭкранированных.Вставить("0", Символ(0)); //Null
	КартаЭкранированных = Новый ФиксированноеСоответствие(КартаЭкранированных);
	
	ДополнениеКартыЭкранированных = Новый Соответствие;
	ДополнениеКартыЭкранированных.Вставить(15, Новый Структура("Инверсивный, Значения", ложь, wPerl));
	ДополнениеКартыЭкранированных.Вставить(16, Новый Структура("Инверсивный, Значения", ложь, dPerl));
	ДополнениеКартыЭкранированных.Вставить(17, Новый Структура("Инверсивный, Значения", ложь, sPerl));
	ДополнениеКартыЭкранированных.Вставить(18, Новый Структура("Инверсивный, Значения", истина, wPerl));
	ДополнениеКартыЭкранированных.Вставить(19, Новый Структура("Инверсивный, Значения", истина, dPerl));
	ДополнениеКартыЭкранированных.Вставить(20, Новый Структура("Инверсивный, Значения", истина, sPerl));	
	ДополнениеКартыЭкранированных = Новый ФиксированноеСоответствие(ДополнениеКартыЭкранированных);
		
	СтруктураКонстант = Новый Структура;
	СтруктураКонстант.Вставить("КартаТерминаторовСтроки", КартаТерминаторовСтроки);
	СтруктураКонстант.Вставить("КартаМетаСимволовКодам", КартаМетаСимволовКодам);
	СтруктураКонстант.Вставить("КартаЭкранированных", КартаЭкранированных);
	СтруктураКонстант.Вставить("КартаЭкранированных", КартаЭкранированных);
	СтруктураКонстант.Вставить("ДополнениеКартыЭкранированных", ДополнениеКартыЭкранированных);
	
	СтруктураКонстантФикс = Новый ФиксированнаяСтруктура(СтруктураКонстант);
	
	Возврат СтруктураКонстантФикс;

КонецФункции // ВернутьСтруктуруКонстантРІС()

// Процедура - Запуск автомата2
//
// Параметры:
//  Паттерн		 - 	 - 
//  ФлагиРежима	 - 	 - 
//
&НаКлиентеНаСервереБезКонтекста
Процедура ЗапускАвтомата(Паттерн, ФлагиРежима, ЗНАЧ ОбрабатываемаяСтрока="", ИмяФайлаНаСервере="")
	
	///На паттерне пустого символа зациклится.
	ФлагРаботыПоСтроке = НЕ ОбрабатываемаяСтрока=""; 
	МеткаВремени = ТекущаяУниверсальнаяДатаВМиллисекундах();	
	Начало = МеткаВремени;
	СтруктураКонстант = ВернутьСтруктуруКонстантРІС();
	МассивИнструкций = Новый Массив;
	МассивИнверсивныхИнструкций = Новый Массив;
	ПроверитьНаСлеши(Паттерн);
	РазобратьПаттерн(Паттерн, МассивИнструкций, МассивИнверсивныхИнструкций, СтруктураКонстант, ФлагиРежима);
	ФлагАктивацииИнверсивногоПотока = МассивИнверсивныхИнструкций.Количество()>0;
	КоличествоМИ = МассивИнструкций.ВГраница()-1; 
	МеткаВремени = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Сообщить("Длительность разбора регулярного выражения: " + Строка(МеткаВремени - Начало) + " миллисек.");
	МеткаВремени = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	///Input
	Если НЕ ФлагРаботыПоСтроке Тогда
		///Файл
		Имя = ИмяФайлаНаСервере;
		ВходнойПоток = Новый ФайловыйПоток(Имя, РежимОткрытияФайла.Открыть, ДоступКФайлу.Чтение);
	Иначе                    
		///Строка
		ВходнойПоток = ПолучитьДвоичныеДанныеИзСтроки(ОбрабатываемаяСтрока).ОткрытьПотокДляЧтения();
	КонецЕсли;
	
	ЧтениеВхода = Новый ЧтениеДанных(ВходнойПоток, КодировкаТекста.UTF8);
	
	ЧтениеВхода.РазделительСтрок = (Символы.ПС);
	ЧтениеВхода.КонвертируемыйРазделительСтрок = (Символы.ПС);
	Размер = ВходнойПоток.Размер();
	
	Если ФлагАктивацииИнверсивногоПотока Тогда
		Если НЕ ФлагРаботыПоСтроке Тогда
			ВходнойПотокИнверс = Новый ФайловыйПоток(Имя, РежимОткрытияФайла.Открыть, ДоступКФайлу.Чтение);
		Иначе
			ВходнойПотокИнверс = ПолучитьДвоичныеДанныеИзСтроки(ОбрабатываемаяСтрока).ДвоичныеДанныеСтрока.ОткрытьПотокДляЧтения();
		КонецЕсли;
		ЧтениеВходаИнверс = Новый ЧтениеДанных(ВходнойПотокИнверс, КодировкаТекста.UTF8, ЧтениеВхода.ПорядокБайтов, ЧтениеВхода.РазделительСтрок, ЧтениеВхода.КонвертируемыйРазделительСтрок);
		РазмерИнверс = ВходнойПотокИнверс.Размер();
	КонецЕсли;
	
	МассивПозиций = Новый Массив;
	МассивИндексовПозиций = Новый Массив;
	МассивИнверсивныхПозиций = Новый Массив;
	МассивИндексовИнверсивныхПозиций = Новый Массив;
	
	ПерваяИнструкция = МассивИнструкций[1];
	ТипПервойИнструкции = ТипЗнч(ПерваяИнструкция);
	ПерваяИнструкцияЭтоЛитерал = ТипПервойИнструкции=Тип("Строка") ИЛИ (ТипПервойИнструкции=Тип("Структура") И ПерваяИнструкция.ИЛИ.Количество());
	ГраницаФлагаПродолжения = ?(ПерваяИнструкцияЭтоЛитерал, 3, 2);
	ЗначениеИндексаИ = ?(ПерваяИнструкцияЭтоЛитерал, 2, 1);
		
	Если ПерваяИнструкцияЭтоЛитерал И ФлагиРежима.CaseInsensitive И НЕ ТипПервойИнструкции = Тип("Структура") Тогда
		МассивПоискаПрефиксов = ВернутьВариантыПрефиксовРН(ПерваяИнструкция); ///Это тоже нужно перенести в разбор паттерна.
	ИначеЕсли ПерваяИнструкцияЭтоЛитерал И ТипПервойИнструкции = Тип("Структура") Тогда
		МассивПоискаПрефиксов = ПерваяИнструкция.ИЛИ;
	Иначе
		МассивПоискаПрефиксов = Новый Массив;
		МассивПоискаПрефиксов.Добавить(ПерваяИнструкция);
	КонецЕсли;
	
	///Exec 
	Пока НЕ ЧтениеВхода.ЧтениеЗавершено Цикл
		СтрокаСовпадения = "";
		СтрокаДоСовпаденияИнверсРезультат = "";
		СтрокаДоСовпаденияИнверсРезультатПредв = "";
		Перерождение = Ложь;
		Если ПерваяИнструкцияЭтоЛитерал Тогда
			Совпадение = ЧтениеВхода.ПропуститьДо(МассивПоискаПрефиксов);
			Если НЕ Совпадение =-1 Тогда
				СтрокаСовпадения = МассивПоискаПрефиксов[Совпадение];
				Позиция = ВходнойПоток.ТекущаяПозиция();
				ПозицияСовпадения = Позиция - ПолучитьБуферДвоичныхДанныхИзСтроки(СтрокаСовпадения).Размер + 1;
				Разность = Позиция - ПозицияСовпадения;
				Если ФлагАктивацииИнверсивногоПотока Тогда
					Если НЕ ПозицияСовпадения=1 Тогда
						///Нужна проверка на Синхрон и окончание строк/текста.
						ИнверсПозиция = ВходнойПотокИнверс.ТекущаяПозиция();
						РазностьИнверс = ПозицияСовпадения - ИнверсПозиция - 1;
						РезультатДоСовпадения = ЧтениеВходаИнверс.Прочитать(РазностьИнверс);
						СтрокаДоСовпаденияИнверс = ПолучитьСтрокуИзДвоичныхДанных(РезультатДоСовпадения.ПолучитьДвоичныеДанные());
						ЧтениеВходаИнверс.Пропустить(Разность);
					Иначе
						СтрокаДоСовпаденияИнверс = "";	
					КонецЕсли;
				КонецЕсли;
			Иначе
				Прервать;
			КонецЕсли;	
		КонецЕсли;
		Если ФлагАктивацииИнверсивногоПотока Тогда
			ПозицияБифуркацииИнверс = СтрДлина(СтрокаДоСовпаденияИнверс)+1;
			Для ИИИ = 0 По МассивИнверсивныхИнструкций.ВГраница() Цикл
				ОднаИнструкция = МассивИнверсивныхИнструкций[ИИИ];
				ТипИнструкции = ТипЗнч(ОднаИнструкция);
				ПозицияБифуркацииИнверс = ПозицияБифуркацииИнверс-1;
				СтрокаДоСовпаденияИнверсРезультатПредв = Конкатенация2(ЧтениеВхода, ОднаИнструкция, ТипИнструкции, СтрокаДоСовпаденияИнверс, Перерождение, ФлагиРежима, ПозицияБифуркацииИнверс, СтруктураКонстант, Истина);
				Если Перерождение Тогда
					Прервать;
				Иначе
					СтрокаДоСовпаденияИнверсРезультат = СтрокаДоСовпаденияИнверсРезультатПредв + СтрокаДоСовпаденияИнверсРезультат;
				КонецЕсли;	
			КонецЦикла;
		КонецЕсли;
		ФлагПродолжения = МассивИнструкций.Количество() > ГраницаФлагаПродолжения И НЕ Перерождение;
		Если ФлагПродолжения Тогда 
			ПозицияБифуркации = ВходнойПоток.ТекущаяПозиция();
			Для ИндексИ = ЗначениеИндексаИ По КоличествоМИ Цикл
				ОднаИнструкция = МассивИнструкций[ИндексИ];
				ТипИнструкции = ТипЗнч(ОднаИнструкция);
				Конкатенация2(ЧтениеВхода, ОднаИнструкция, ТипИнструкции, СтрокаСовпадения, Перерождение, ФлагиРежима, ПозицияБифуркации, СтруктураКонстант);
				Если Перерождение Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если Перерождение Тогда
			Если НЕ ПерваяИнструкцияЭтоЛитерал Тогда
				ЧтениеВхода.ПрочитатьСимволы(1);	
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		///Проверить...
		Если ФлагАктивацииИнверсивногоПотока Тогда
			СтрокаСовпадения = СтрокаДоСовпаденияИнверсРезультат + СтрокаСовпадения;
			ПозицияИнверс = ВходнойПотокИнверс.ТекущаяПозиция();
			///Активировать только по флагу отладки, чтобы не кушало память
			//МассивИнверсивныхПозиций.Добавить(СтрокаДоСовпаденияИнверс);
			//МассивИндексовПозиций.Добавить(ПозицияБифуркацииИнверс);
			///Проверить, особенно по инлексам.
		КонецЕсли;
		
		Позиция = ВходнойПоток.ТекущаяПозиция();
		МассивПозиций.Добавить(СтрокаСовпадения);
		///Это тяжелая строка. Из-за преобразования. Нужно смотреть, может она лишняя.
		МассивИндексовПозиций.Добавить(Позиция - ПолучитьБуферДвоичныхДанныхИзСтроки(СтрокаСовпадения).Размер + 1);
		
		Если НЕ ФлагиРежима.Global Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	ЧтениеВхода.Закрыть();
	ВходнойПоток.Закрыть();
	Если ФлагАктивацииИнверсивногоПотока Тогда
		ЧтениеВходаИнверс.Закрыть();
		ВходнойПотокИнверс.Закрыть();
	КонецЕсли;
	
	Окончание = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Сообщить("Текущая позиция входного потока: " + Строка(Позиция));
	Сообщить("Текущая позиция инверсивного потока: " + ?(ФлагАктивацииИнверсивногоПотока, Строка(ПозицияИнверс), "Неактивирован."));
	Сообщить("Количество совпадений паттерна в входном потоке: " + Строка(МассивПозиций.Количество()));
	Сообщить("Длительность вызова регулярного выражения: " + Строка(Окончание - МеткаВремени) + " миллисек.");
	
КонецПроцедуры

// Процедура - Разобрать паттерн
//
// Параметры:
//  Паттерн						 - 	 - 
//  МассивИнструкций			 - 	 - 
//  МассивИнверсивныхИнструкций	 - 	 - 
//  СтруктураКонстант			 - 	 - 
//  ФлагиРежима					 - 	 - 
//
&НаКлиентеНаСервереБезКонтекста
Процедура РазобратьПаттерн(Паттерн, МассивИнструкций, МассивИнверсивныхИнструкций, СтруктураКонстант, ФлагиРежима)
	
	ПаттернВБуфер = ПолучитьБуферДвоичныхДанныхИзСтроки(Паттерн);
	ПаттернПоток = Новый ПотокВПамяти(ПаттернВБуфер);
	ЧтениеПаттерна = Новый ЧтениеДанных(ПаттернПоток);
	РазмерПаттерна = ПаттернПоток.Размер();
	
	ФлагЛитерала = 0; ///Для группировок до 5-символов в инструкциях-литералах.
	КонстантаФлагЛитерала = Ложь; ///Взводится один раз. Если есть основа для поиска, но впереди есть инструкции c неопределенностью, то они становятся инверсивными.	
	СписокИнверсивныхИнструкций = Новый СписокЗначений;
	КартаСтартСтоп = Новый Соответствие;
	КартаГруппИЛИ = Новый Соответствие;
	ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ = -1;
	ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс = -1;
	ФлагИнверсииГруппыИЛИ = Ложь;
	МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ = Новый Массив;	
	
	Пока НЕ ЧтениеПаттерна.ЧтениеЗавершено Цикл
		СимволПаттерна = ЧтениеПаттерна.ПрочитатьСимволы(1);
		Если НЕ ПроверитьСимвол(СимволПаттерна) Тогда
			ВызватьИсключение("Некорректный символ в паттерне!");
		КонецЕсли;
		Если КартаСтартСтоп.Количество() И КартаСтартСтоп[0] = 1 Тогда
			Если НРег(СимволПаттерна) = "g" Тогда
				ФлагиРежима.Global = Истина;
			ИначеЕсли НРег(СимволПаттерна) = "m" Тогда
				ФлагиРежима.Multiline = Истина;
			ИначеЕсли НРег(СимволПаттерна) = "i" Тогда
				ФлагиРежима.CaseInsensitive = Истина;
			ИначеЕсли НРег(СимволПаттерна) = "s" Тогда
				ФлагиРежима.Singleline = Истина;
			ИначеЕсли НРег(СимволПаттерна) = "u" Тогда
				ФлагиРежима.Unicode = Истина;
			Иначе	
				ВызватьИсключение("В паттерне символы после инструкции Стоп!");
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		ЗначениеВКартеМета = СтруктураКонстант.КартаМетаСимволовКодам.Получить(СимволПаттерна);
		Если ЗначениеВКартеМета = 0 Тогда //Старт
			Если КартаСтартСтоп.Количество() = 0 Тогда
				Если МассивИнструкций.ВГраница()=-1 Тогда 
					МассивИнструкций.Добавить(ЗначениеВКартеМета);
				Иначе
					///Маркер ошибки.
					МассивИнструкций.Добавить(Неопределено);
				КонецЕсли;
				КартаСтартСтоп.Вставить(0, 0);
			ИначеЕсли КартаСтартСтоп.Количество() = 1 Тогда
				Если КартаСтартСтоп[0] = 0 Тогда
					///Вот тут не очень хорошо. Нужно переделать.
					Если НЕ (ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ = -1 И ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс = -1) Тогда
						///Вот тут не очень хорошо. Нужно переделать.
						//МассивИнструкций.Добавить(Неопределено);
						ВызватьИсключение("Не закрыта группа ИЛИ_НЕИЛИ!");
					КонецЕсли;
					КартаСтартСтоп[0] = 1;
					МассивИнструкций.Добавить(ЗначениеВКартеМета);
				Иначе
					МассивИнструкций.Добавить(Неопределено);
				КонецЕсли;
			Иначе
				МассивИнструкций.Добавить(Неопределено);
			КонецЕсли;
		ИначеЕсли ЗначениеВКартеМета = Неопределено Тогда
			Если НЕ КартаГруппИЛИ.Количество() Тогда
				Если ФлагЛитерала Тогда
					Литерал = МассивИнструкций[ФлагЛитерала-1];
					СлайсЛитерала = Литерал + СимволПаттерна;
					МассивИнструкций[ФлагЛитерала-1] = СлайсЛитерала;
					КритическаяДлинаСлайса = СтрДлина(СлайсЛитерала)=5;
					Если КритическаяДлинаСлайса Тогда
						ФлагЛитерала = 0;
					Иначе
						ФлагЛитерала = МассивИнструкций.Количество();
					КонецЕсли;
				Иначе
					МассивИнструкций.Добавить(СимволПаттерна);
					ФлагЛитерала = МассивИнструкций.Количество();
				КонецЕсли;
				///Проверить
				КонстантаФлагЛитерала = Истина;
			Иначе
				///Проверить.
				Если ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ > -1 Тогда 
					ОжидаемаяГруппаИЛИ_НЕИЛИ = МассивИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ];
				ИначеЕсли ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс > -1 Тогда
					ОжидаемаяГруппаИЛИ_НЕИЛИ = СписокИнверсивныхИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс].Значение;
				Иначе	
					 ВызватьИсключение("Информация для команды поддержки: Неотмечен флаг положения группы ИЛИ_НЕИЛИ.");
				КонецЕсли;
				Если ТипЗнч(ОжидаемаяГруппаИЛИ_НЕИЛИ) = Тип("Структура") Тогда
					Если НЕ (ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("ИЛИ") И ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("НЕИЛИ")) Тогда
						ВызватьИсключение("Отсутствуют коллекции группы ИЛИ/НЕИЛИ!");	
					КонецЕсли;
					МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Добавить(СимволПаттерна);
				Иначе
					ВызватьИсключение("Неожиданный тип коллекции группы ИЛИ/НЕИЛИ!");
				КонецЕсли;
				ФлагЛитерала = 0;
			КонецЕсли;	
		ИначеЕсли ЗначениеВКартеМета = 1 Тогда  //Экран
			Если НЕ ЧтениеПаттерна.ЧтениеЗавершено Тогда
				ВторойСимволИнструкцииПаттерна = ЧтениеПаттерна.ПрочитатьСимволы(1);
				Если НЕ ПроверитьСимвол(ВторойСимволИнструкцииПаттерна) Тогда
					ВызватьИсключение("Некорректный символ в паттерне!");
				КонецЕсли;
			Иначе
				ВторойСимволИнструкцииПаттерна = "";
			КонецЕсли;
			ЗначениеВКартеЭкранированных = СтруктураКонстант.КартаЭкранированных.Получить(ВторойСимволИнструкцииПаттерна);
			Если ЗначениеВКартеЭкранированных = Неопределено Тогда
				Если НЕ КартаГруппИЛИ.Количество() Тогда
					Если ФлагЛитерала Тогда
						Литерал = МассивИнструкций[ФлагЛитерала-1];
						СлайсЛитерала = Литерал + ВторойСимволИнструкцииПаттерна;
						МассивИнструкций[ФлагЛитерала-1] = СлайсЛитерала;
						КритическаяДлинаСлайса = СтрДлина(СлайсЛитерала)=5;
						Если КритическаяДлинаСлайса Тогда
							ФлагЛитерала = 0;
						Иначе	
							ФлагЛитерала = МассивИнструкций.Количество();
						КонецЕсли;
					Иначе
						МассивИнструкций.Добавить(ВторойСимволИнструкцииПаттерна);
						ФлагЛитерала = МассивИнструкций.Количество();
					КонецЕсли;
					КонстантаФлагЛитерала = Истина;
				Иначе
					///Проверить.
					Если ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ > -1 Тогда 
						ОжидаемаяГруппаИЛИ_НЕИЛИ = МассивИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ];
					ИначеЕсли ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс > -1 Тогда
						ОжидаемаяГруппаИЛИ_НЕИЛИ = СписокИнверсивныхИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс].Значение;
					Иначе	
						ВызватьИсключение("Информация для команды поддержки: Неотмечен флаг положения группы ИЛИ_НЕИЛИ.");
					КонецЕсли;
					Если ТипЗнч(ОжидаемаяГруппаИЛИ_НЕИЛИ) = Тип("Структура") Тогда
						Если НЕ (ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("ИЛИ") И ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("НЕИЛИ")) Тогда
							ВызватьИсключение("Отсутствуют коллекции группы ИЛИ/НЕИЛИ!");	
						КонецЕсли;
						МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Добавить(ВторойСимволИнструкцииПаттерна);
					Иначе
						ВызватьИсключение("Неожиданный тип коллекции группы ИЛИ/НЕИЛИ!");
					КонецЕсли;
					ФлагЛитерала = 0;
				КонецЕсли;	
			Иначе
				Если ТипЗнч(ЗначениеВКартеЭкранированных) = Тип("Строка") Тогда
					Если НЕ КартаГруппИЛИ.Количество() Тогда
						Если ФлагЛитерала Тогда
							Литерал = МассивИнструкций[ФлагЛитерала-1];
							СлайсЛитерала = Литерал + ЗначениеВКартеЭкранированных;
							МассивИнструкций[ФлагЛитерала-1] = СлайсЛитерала;
							КритическаяДлинаСлайса = СтрДлина(СлайсЛитерала)=5;
							Если КритическаяДлинаСлайса Тогда
								ФлагЛитерала = 0;
							Иначе
								ФлагЛитерала = МассивИнструкций.Количество();
							КонецЕсли;
						Иначе
							МассивИнструкций.Добавить(ЗначениеВКартеЭкранированных);
							ФлагЛитерала = МассивИнструкций.Количество();
						КонецЕсли;
						КонстантаФлагЛитерала = Истина;
					Иначе
						///Проверить.
						Если ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ > -1 Тогда 
							ОжидаемаяГруппаИЛИ_НЕИЛИ = МассивИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ];
						ИначеЕсли ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс > -1 Тогда
							ОжидаемаяГруппаИЛИ_НЕИЛИ = СписокИнверсивныхИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс].Значение;
						Иначе	
					 		ВызватьИсключение("Информация для команды поддержки: Неотмечен флаг положения группы ИЛИ_НЕИЛИ.");
						КонецЕсли;
						Если ТипЗнч(ОжидаемаяГруппаИЛИ_НЕИЛИ) = Тип("Структура") Тогда
							Если НЕ (ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("ИЛИ") И ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("НЕИЛИ")) Тогда
								ВызватьИсключение("Отсутствуют коллекции группы ИЛИ/НЕИЛИ!");	
							КонецЕсли;
							МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Добавить(ЗначениеВКартеЭкранированных);
						Иначе
							ВызватьИсключение("Неожиданный тип коллекции группы ИЛИ/НЕИЛИ!");
						КонецЕсли;
						ФлагЛитерала = 0;
					КонецЕсли;
				ИначеЕсли ТипЗнч(ЗначениеВКартеЭкранированных) = Тип("Число") Тогда //Диапазоны
					СтруктураДиапазона = СтруктураКонстант.ДополнениеКартыЭкранированных[ЗначениеВКартеЭкранированных];
					Если НЕ СтруктураДиапазона = Неопределено Тогда
						Диапазон = РазобратьДиапазонПоСтруктуре(СтруктураДиапазона);						
						Если НЕ КартаГруппИЛИ.Количество() Тогда
							Если НЕ КонстантаФлагЛитерала Тогда
								Если ТипЗнч(Диапазон) = Тип("Массив") Тогда
									СписокИнверсивныхИнструкций.Добавить(Новый Структура("ИЛИ, НЕИЛИ, Медленно, СтрДлина", Диапазон, Новый Соответствие, Истина, Неопределено), СписокИнверсивныхИнструкций.Количество());
								ИначеЕсли ТипЗнч(Диапазон) = Тип("Соответствие") Тогда
									СписокИнверсивныхИнструкций.Добавить(Новый Структура("ИЛИ, НЕИЛИ, Медленно, СтрДлина", Новый Массив, Диапазон, Истина, Неопределено), СписокИнверсивныхИнструкций.Количество());
								Иначе
									ВызватьИсключение("Неожиданный тип значения диапазона!");
								КонецЕсли;
							Иначе
								Если ТипЗнч(Диапазон) = Тип("Массив") Тогда
									МассивИнструкций.Добавить(Новый Структура("ИЛИ, НЕИЛИ, Медленно, СтрДлина", Диапазон, Новый Соответствие, Истина, Неопределено));
								ИначеЕсли ТипЗнч(Диапазон) = Тип("Соответствие") Тогда
									МассивИнструкций.Добавить(Новый Структура("ИЛИ, НЕИЛИ, Медленно, СтрДлина", Новый Массив, Диапазон, Истина, Неопределено));
								Иначе
									ВызватьИсключение("Неожиданный тип значения диапазона!");
								КонецЕсли;
							КонецЕсли;
						Иначе
							Если ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ > -1 Тогда 
								ОжидаемаяГруппаИЛИ_НЕИЛИ = МассивИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ];
							ИначеЕсли ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс > -1 Тогда
								ОжидаемаяГруппаИЛИ_НЕИЛИ = СписокИнверсивныхИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс].Значение;
							Иначе	
					 			ВызватьИсключение("Информация для команды поддержки: Неотмечен флаг положения группы ИЛИ_НЕИЛИ.");
							КонецЕсли;
							Если ТипЗнч(ОжидаемаяГруппаИЛИ_НЕИЛИ) = Тип("Структура") Тогда
								Если НЕ (ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("ИЛИ") И ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("НЕИЛИ")) Тогда
									ВызватьИсключение("Отсутствуют коллекции группы ИЛИ/НЕИЛИ!");	
								КонецЕсли;
								ТипДиапазона  = ТипЗнч(Диапазон);
								///Проверить
								Если ФлагИнверсииГруппыИЛИ Тогда
									Если ТипДиапазона = Тип("Массив") Тогда
										Для Каждого ЭлементМассиваДиапазона ИЗ Диапазон Цикл
											ИндексВМассивеИЛИИнверс = ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементМассиваДиапазона);
											Если ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементМассиваДиапазона) = Неопределено Тогда
												Если ИндексВМассивеИЛИИнверс = Неопределено Тогда
													ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ.Вставить(ЭлементМассиваДиапазона, Ложь);
												Иначе
													ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Удалить(ИндексВМассивеИЛИИнверс);
												КонецЕсли;
											КонецЕсли;
										КонецЦикла;
									ИначеЕсли ТипДиапазона = Тип("Соответствие") Тогда
										Для Каждого ЭлементСоответствияДиапазона ИЗ Диапазон Цикл
											ИндексВМассивеИЛИИнверс = ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементСоответствияДиапазона.Ключ);
											Если ИндексВМассивеИЛИИнверс = Неопределено Тогда
												Если ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ[ЭлементСоответствияДиапазона] = Неопределено Тогда
													ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Добавить(ЭлементСоответствияДиапазона.Ключ);
												Иначе
													ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Удалить(ИндексВМассивеИЛИИнверс);
												КонецЕсли;
											КонецЕсли;
										КонецЦикла;
									Иначе
										ВызватьИсключение("Неожиданный тип коллекции диапазона!");	
									КонецЕсли;	
								Иначе 
									Если ТипДиапазона = Тип("Массив") Тогда
										Для Каждого ЭлементМассиваДиапазона ИЗ Диапазон Цикл
											ИндексВМассивеИЛИ = ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементМассиваДиапазона);
											Если ИндексВМассивеИЛИ = Неопределено Тогда
												Если ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ[ЭлементМассиваДиапазона] = Неопределено Тогда
													ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Добавить(ЭлементМассиваДиапазона);
												Иначе
													ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ.Удалить(ЭлементМассиваДиапазона);
												КонецЕсли;
											КонецЕсли;
										КонецЦикла;
									ИначеЕсли ТипДиапазона = Тип("Соответствие") Тогда
										Для Каждого ЭлементСоответствияДиапазона ИЗ Диапазон Цикл
											Если ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ[ЭлементСоответствияДиапазона.Ключ] = Неопределено Тогда
												ИндексВМассивеИЛИ = ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементСоответствияДиапазона.Ключ);
												Если ИндексВМассивеИЛИ = Неопределено Тогда
													ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ.Вставить(ЭлементСоответствияДиапазона.Ключ, Ложь);
												Иначе
													ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Удалить(ИндексВМассивеИЛИ);
												КонецЕсли;
											КонецЕсли;
										КонецЦикла;
									Иначе
										ВызватьИсключение("Неожиданный тип коллекции диапазона!");	
									КонецЕсли;
								КонецЕсли;
								МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Добавить(ЗначениеВКартеЭкранированных);
							Иначе
								ВызватьИсключение("Неожиданный тип коллекции группы ИЛИ/НЕИЛИ!");
							КонецЕсли;
						КонецЕсли;
					Иначе
						МассивИнструкций.Добавить(Неопределено);
					КонецЕсли;
					ФлагЛитерала = 0;
				Иначе
					МассивИнструкций.Добавить(ЗначениеВКартеЭкранированных);					
					ФлагЛитерала = 0;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ЗначениеВКартеМета = 10 Тогда
			///ГруппаИЛИ откр
			///Вложенности группИЛИ на момент 2021 нет. Но оставим задел.
			///эти группы по критерию поиска ближе к диапазонам, нежели к литералам. 
			///Поэтому нужно их убирать в инструкции инверсивного потока.
			Если НЕ КартаГруппИЛИ.Количество() Тогда
				КартаГруппИЛИ.Вставить(0, 0);
				///Проверить.
				Если НЕ КонстантаФлагЛитерала Тогда
					СписокИнверсивныхИнструкций.Добавить(Новый Структура("ИЛИ, НЕИЛИ, Медленно, СтрДлина", Новый Массив, Новый Соответствие, Истина, Неопределено), СписокИнверсивныхИнструкций.Количество());
					ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс = СписокИнверсивныхИнструкций.Количество()-1;
				Иначе
					МассивИнструкций.Добавить(Новый Структура("ИЛИ, НЕИЛИ, Медленно, СтрДлина", Новый Массив, Новый Соответствие, Истина, Неопределено));
					ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ = МассивИнструкций.Количество()-1;
				КонецЕсли;	
			Иначе
				Если ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ > -1 Тогда 
					ОжидаемаяГруппаИЛИ_НЕИЛИ = МассивИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ];
				ИначеЕсли ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс > -1 Тогда
					ОжидаемаяГруппаИЛИ_НЕИЛИ = СписокИнверсивныхИнструкций[ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс].Значение;
				Иначе	
					 ВызватьИсключение("Информация для команды поддержки: Неотмечен флаг положения группы ИЛИ_НЕИЛИ.");
				КонецЕсли;
				Если ТипЗнч(ОжидаемаяГруппаИЛИ_НЕИЛИ) = Тип("Структура") Тогда
					Если НЕ (ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("ИЛИ") И ОжидаемаяГруппаИЛИ_НЕИЛИ.Свойство("НЕИЛИ")) Тогда
						ВызватьИсключение("Отсутствуют коллекции группы ИЛИ/НЕИЛИ!");	
					КонецЕсли;
					МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Добавить(СимволПаттерна);
				Иначе
					ВызватьИсключение("Неожиданный тип коллекции группы ИЛИ/НЕИЛИ!");
				КонецЕсли;	
			КонецЕсли;
			ФлагЛитерала = 0;
		ИначеЕсли ЗначениеВКартеМета = 9 Тогда
			///ГруппаИЛИ закр
			Если НЕ КартаГруппИЛИ.Количество() Тогда
				Если ФлагЛитерала Тогда
					Литерал = МассивИнструкций[ФлагЛитерала-1];
					СлайсЛитерала = Литерал + СимволПаттерна;
					МассивИнструкций[ФлагЛитерала-1] = СлайсЛитерала;
					КритическаяДлинаСлайса = СтрДлина(СлайсЛитерала)=5;
					Если КритическаяДлинаСлайса Тогда
						ФлагЛитерала = 0;
					Иначе
						ФлагЛитерала = МассивИнструкций.Количество();
					КонецЕсли;
				Иначе
					МассивИнструкций.Добавить(СимволПаттерна);
					ФлагЛитерала = МассивИнструкций.Количество();
				КонецЕсли;
				///Подумать...
			    ///КонстантаФлагЛитерала = Истина;
			Иначе
				Если МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Количество() Тогда
					///Придется обходить массив дважды.
					Отказ = Ложь;
					СтруктураПарсингаДиапазона = Новый Структура("Инверсивный, Значения", Ложь, Новый Массив);
					МассивЗначенийПарсингаДиапазонов = СтруктураПарсингаДиапазона.Значения; 
					Пока НЕ МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Найти("-") = Неопределено Цикл 
						Для ИндексЭМЛИ = 0 По МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.ВГраница() Цикл
							Если МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ[ИндексЭМЛИ] = "-" Тогда
								Если МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.ВГраница() >= ИндексЭМЛИ+1 И ИндексЭМЛИ > 0 Тогда
									Если ТипЗнч(МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ[ИндексЭМЛИ+1])	= Тип("Строка") И ТипЗнч(МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ[ИндексЭМЛИ-1]) = Тип("Строка") Тогда
										Если КодСимвола(МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ[ИндексЭМЛИ+1])>=КодСимвола(МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ[ИндексЭМЛИ-1]) Тогда
											МассивЗначенийПарсингаДиапазонов.Добавить(КодСимвола(МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ[ИндексЭМЛИ-1]));
											МассивЗначенийПарсингаДиапазонов.Добавить(КодСимвола(МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ[ИндексЭМЛИ+1]));
											СтруктураПарсингаДиапазона = Новый Структура("Инверсивный, Значения", Ложь, Новый ФиксированныйМассив(МассивЗначенийПарсингаДиапазонов));
											///Вставляем в основную коллекцию группы.
											ДиапазонЛитеральный = РазобратьДиапазонПоСтруктуре(СтруктураПарсингаДиапазона);
											Если ФлагИнверсииГруппыИЛИ Тогда
												Если ТипЗнч(ДиапазонЛитеральный) = Тип("Массив") Тогда
													Для Каждого ЭлементМассиваДиапазона ИЗ ДиапазонЛитеральный Цикл
														ИндексВМассивеИЛИИнверс = ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементМассиваДиапазона);
														Если ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементМассиваДиапазона) = Неопределено Тогда
															Если ИндексВМассивеИЛИИнверс = Неопределено Тогда
																ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ.Вставить(ЭлементМассиваДиапазона, Ложь);
															Иначе
																ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Удалить(ИндексВМассивеИЛИИнверс);
															КонецЕсли;
														КонецЕсли;
													КонецЦикла;
												Иначе
													ВызватьИсключение("Неожиданный тип коллекции диапазона!");	
												КонецЕсли;	
											Иначе 
												Если ТипЗнч(ДиапазонЛитеральный) = Тип("Массив") Тогда
													Для Каждого ЭлементМассиваДиапазона ИЗ ДиапазонЛитеральный Цикл
														ИндексВМассивеИЛИ = ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементМассиваДиапазона);
														Если ИндексВМассивеИЛИ = Неопределено Тогда
															Если ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ[ЭлементМассиваДиапазона] = Неопределено Тогда
																ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Добавить(ЭлементМассиваДиапазона);
															Иначе
																ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ.Удалить(ЭлементМассиваДиапазона);
															КонецЕсли;
														КонецЕсли;
													КонецЦикла;
												Иначе
													ВызватьИсключение("Неожиданный тип коллекции диапазона!");	
												КонецЕсли;
											КонецЕсли;
											///Три символа удаляем.
											МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Удалить(ИндексЭМЛИ+1);
											МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Удалить(ИндексЭМЛИ);
											МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Удалить(ИндексЭМЛИ-1);
											Прервать;
										Иначе
											МассивИнструкций.Добавить(Неопределено);
											Отказ = Истина;
											Прервать;
										КонецЕсли;	
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЦикла;
					КонецЦикла;
					
					Если НЕ Отказ Тогда
						Для Каждого ЭлементМассиваЛитеральныхИнструкций Из МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ Цикл
							Если ТипЗнч(ЭлементМассиваЛитеральныхИнструкций) = Тип("Строка") Тогда
								Если ФлагИнверсииГруппыИЛИ Тогда
									Если ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ[ЭлементМассиваЛитеральныхИнструкций] = Неопределено Тогда
										ИндексЭлементаГруппыИЛИИнверс = ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементМассиваЛитеральныхИнструкций);
										Если ИндексЭлементаГруппыИЛИИнверс = Неопределено Тогда
											ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ.Вставить(ЭлементМассиваЛитеральныхИнструкций, Ложь);
										Иначе
											ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Удалить(ИндексЭлементаГруппыИЛИИнверс);
										КонецЕсли;
									КонецЕсли;
								Иначе
									ИндексЭлементаГруппыИЛИИнверс = ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Найти(ЭлементМассиваЛитеральныхИнструкций);
									Если ИндексЭлементаГруппыИЛИИнверс = Неопределено Тогда
										Если ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ[ЭлементМассиваЛитеральныхИнструкций] = Неопределено Тогда
											ОжидаемаяГруппаИЛИ_НЕИЛИ.ИЛИ.Добавить(ЭлементМассиваЛитеральныхИнструкций);
										Иначе
											ОжидаемаяГруппаИЛИ_НЕИЛИ.НЕИЛИ.Удалить(ЭлементМассиваЛитеральныхИнструкций);
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
				КартаГруппИЛИ.Удалить(0);
				ФлагЛитерала = 0;
				ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ = -1;
				ИндексСтруктурыГруппыИЛИ_ГруппыНЕИЛИ_Инверс = -1;
				ФлагИнверсииГруппыИЛИ = Ложь;
				МассивЛитеральныхОперацийГруппыИЛИ_НЕИЛИ.Очистить();
				///Нужно обработать вариант ошибки при паттерне []
			КонецЕсли;	
		ИначеЕсли ЗначениеВКартеМета = 13 Тогда
			Если КартаГруппИЛИ.Количество() Тогда
				ФлагИнверсииГруппыИЛИ = Истина;
			Иначе
				///Это мета "начало строки"
				МассивИнструкций.Добавить(ЗначениеВКартеМета);
			КонецЕсли;
			ФлагЛитерала = 0;
		Иначе
			///Пока нет решения для паттернов типа /./ или /\w/ Global очень в них медлителен.
			Если НЕ КонстантаФлагЛитерала Тогда
				Если ЗначениеВКартеМета = 2 Тогда
					СписокИнверсивныхИнструкций.Добавить(Новый Структура("ИЛИ, НЕИЛИ, Медленно, СтрДлина", Новый Массив, СтруктураКонстант.КартаТерминаторовСтроки, Истина, Неопределено), СписокИнверсивныхИнструкций.Количество());
				Иначе	
					СписокИнверсивныхИнструкций.Добавить(-ЗначениеВКартеМета, СписокИнверсивныхИнструкций.Количество());
				КонецЕсли;	
			Иначе
				Если ЗначениеВКартеМета = 2 Тогда
					МассивИнструкций.Добавить(Новый Структура("ИЛИ, НЕИЛИ, Медленно, СтрДлина", Новый Массив, СтруктураКонстант.КартаТерминаторовСтроки, Истина, Неопределено));
				Иначе	
					МассивИнструкций.Добавить(ЗначениеВКартеМета);
				КонецЕсли;
				ФлагЛитерала = 0;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если КартаСтартСтоп.Количество() = 0 ИЛИ КартаСтартСтоп[0] = 0 Тогда
		МассивИнструкций.Добавить(Неопределено);	
	КонецЕсли;
	
	КоличествоЭлементовСпискаИИ = СписокИнверсивныхИнструкций.Количество();
	
	///Возвращаем инверсивные позиции, если нет литералов в основную последовательность.
	Если МассивИнструкций.Количество()<= 2 И КоличествоЭлементовСпискаИИ > 0 Тогда
		Для ИндексВозвращаемогоЭлемента = 1 По КоличествоЭлементовСпискаИИ Цикл
			ВозвращаемыйЭлемент = СписокИнверсивныхИнструкций.Получить(ИндексВозвращаемогоЭлемента-1).Значение;
			///Спорно делать массивы инверсивными инструкциями. Хоть какая-то, но база.
			Если НЕ ТипЗнч(ВозвращаемыйЭлемент) = Тип("Структура") Тогда
				МассивИнструкций.Вставить(ИндексВозвращаемогоЭлемента, - ВозвращаемыйЭлемент);
			Иначе
				МассивИнструкций.Вставить(ИндексВозвращаемогоЭлемента, ВозвращаемыйЭлемент);
			КонецЕсли;
		КонецЦикла;
		СписокИнверсивныхИнструкций.Очистить();
	КонецЕсли;	
	
	ЧтениеПаттерна.Закрыть();
	ПаттернПоток.Закрыть();
	
	СписокИнверсивныхИнструкций.СортироватьПоПредставлению(НаправлениеСортировки.Убыв);
	МассивИнверсивныхИнструкций = СписокИнверсивныхИнструкций.ВыгрузитьЗначения();
	СписокИнверсивныхИнструкций.Очистить();
	
	///Постобработка группИЛИ/НЕИЛИ. Вынести в отдельную процедуру.
	Для Каждого ИскомаяИнструкция Из МассивИнструкций Цикл
		Если ТипЗнч(ИскомаяИнструкция) = Тип("Структура") Тогда
			Если ИскомаяИнструкция.ИЛИ.Количество() Тогда
				Если ФлагиРежима.CaseInsensitive Тогда
					ИскомаяИнструкция.ИЛИ = ВернутьВариантыПрефиксовРН(ИскомаяИнструкция.ИЛИ);	
				КонецЕсли;
			КонецЕсли;
			Если ИскомаяИнструкция.НЕИЛИ.Количество() Тогда
				Если ФлагиРежима.CaseInsensitive Тогда
					ИскомаяИнструкция.НЕИЛИ = ВернутьВариантыПрефиксовРН(ИскомаяИнструкция.НЕИЛИ);
					Если ИскомаяИнструкция.ИЛИ.Количество() Тогда
						ИндексЭлементаИЛИ = -1;
						Для Каждого ЭлементИЛИ Из ИскомаяИнструкция.ИЛИ Цикл
							ИндексЭлементаИЛИ = ИндексЭлементаИЛИ + 1;
							АналогВСоответствии = ИскомаяИнструкция.НЕИЛИ[ЭлементИЛИ];
							Если НЕ АналогВСоответствии = Неопределено Тогда
								ИскомаяИнструкция.ИЛИ.Удалить(ИскомаяИнструкция.ИЛИ[ИндексЭлементаИЛИ]);
								ИскомаяИнструкция.НЕИЛИ.Удалить(ЭлементИЛИ);
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;	
			КонецЕсли;
			Если ИскомаяИнструкция.ИЛИ.Количество() Тогда
				МинЭлемент = СтрДлина(ИскомаяИнструкция.ИЛИ[0]);
				МаксЭлемент = СтрДлина(ИскомаяИнструкция.ИЛИ[0]);
				Для Каждого ЭлементИЛИ Из ИскомаяИнструкция.ИЛИ Цикл
					МинЭлемент = Мин(СтрДлина(ЭлементИЛИ), МинЭлемент);
					МаксЭлемент = Макс(СтрДлина(ЭлементИЛИ), МаксЭлемент);
				КонецЦикла;
				Если МинЭлемент = МаксЭлемент Тогда
					ИскомаяИнструкция.Медленно = Ложь;
					ИскомаяИнструкция.СтрДлина = МинЭлемент;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ИскомаяИнструкцияИнверс Из МассивИнверсивныхИнструкций Цикл
		Если ТипЗнч(ИскомаяИнструкцияИнверс) = Тип("Структура") Тогда
			Если ИскомаяИнструкцияИнверс.ИЛИ.Количество() Тогда
				Если ФлагиРежима.CaseInsensitive Тогда
					ИскомаяИнструкцияИнверс.ИЛИ = ВернутьВариантыПрефиксовРН(ИскомаяИнструкцияИнверс.ИЛИ);	
				КонецЕсли;
			КонецЕсли;
			Если ИскомаяИнструкцияИнверс.НЕИЛИ.Количество() Тогда
				Если ФлагиРежима.CaseInsensitive Тогда
					ИскомаяИнструкцияИнверс.НЕИЛИ = ВернутьВариантыПрефиксовРН(ИскомаяИнструкцияИнверс.НЕИЛИ);
					Если ИскомаяИнструкцияИнверс.ИЛИ.Количество() Тогда
						ИндексЭлементаИЛИИнверс = -1;
						Для Каждого ЭлементИЛИИнверс Из ИскомаяИнструкцияИнверс.ИЛИ Цикл
							ИндексЭлементаИЛИИнверс = ИндексЭлементаИЛИИнверс + 1;
							АналогВСоответствииИнверс = ИскомаяИнструкцияИнверс.НЕИЛИ[ЭлементИЛИИнверс];
							Если НЕ АналогВСоответствииИнверс = Неопределено Тогда
								ИскомаяИнструкцияИнверс.ИЛИ.Удалить(ИскомаяИнструкцияИнверс.ИЛИ[ИндексЭлементаИЛИИнверс]);
								ИскомаяИнструкцияИнверс.НЕИЛИ.Удалить(ЭлементИЛИИнверс);
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если ИскомаяИнструкцияИнверс.ИЛИ.Количество() Тогда
				МинЭлементИнверс = СтрДлина(ИскомаяИнструкцияИнверс.ИЛИ[0]);
				МаксЭлементИнверс = СтрДлина(ИскомаяИнструкцияИнверс.ИЛИ[0]);
				Для Каждого ЭлементИЛИИнверс Из ИскомаяИнструкцияИнверс.ИЛИ Цикл
					МинЭлементИнверс = Мин(СтрДлина(ЭлементИЛИИнверс), МинЭлементИнверс);
					МаксЭлементИнверс = Макс(СтрДлина(ЭлементИЛИИнверс), МаксЭлементИнверс);
				КонецЦикла;
				Если МинЭлементИнверс = МаксЭлементИнверс Тогда
					ИскомаяИнструкцияИнверс.Медленно = Ложь;
					ИскомаяИнструкцияИнверс.СтрДлина = МинЭлементИнверс;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ФлагОшибкиПаттерна = МассивИнструкций.Найти(Неопределено);
	ФлагОшибкиПаттернаИнверс = МассивИнверсивныхИнструкций.Найти(Неопределено);
	
	
	///ΤοDO переделать под подобие нативных исключительных ситуаций.
	///Индекс он с Нуля начинается ))
	Если НЕ ФлагОшибкиПаттерна = Неопределено Тогда
		ВызватьИсключение("Ошибка в паттерне. Индекс инструкции: " + ФлагОшибкиПаттерна);
	ИначеЕсли НЕ ФлагОшибкиПаттернаИнверс = Неопределено Тогда
		ВызватьИсключение("Ошибка в паттерне. Индекс инверсивной инструкции: " + ФлагОшибкиПаттернаИнверс);
	ИначеЕсли МассивИнструкций.Количество() < 3 Тогда
		ВызватьИсключение("Паттерн пустой!");
	КонецЕсли;

КонецПроцедуры // РазобратьПаттерн()

// Процедура - Проверить на слеши
//
// Параметры:
//  Паттерн	 - 	 - 
//
&НаКлиентеНаСервереБезКонтекста
Процедура ПроверитьНаСлеши(Паттерн)

	Если НЕ Сред(Паттерн, 1, 1) = "/" Тогда
		Паттерн = "/" + Паттерн + "/";
	КонецЕсли;

КонецПроцедуры // ПроверитьНаОбратныеСлеши()

// Функция - Конкатенация2
//
// Параметры:
//  ЧтениеДанных			 - 	 - 
//  Инструкция				 - 	 - 
//  ТипИнструкции			 - 	 - 
//  СтрокаКонкатенации		 - 	 - 
//  Перерождение			 - 	 - 
//  ФлагиРежима				 - 	 - 
//  ПозицияБифуркации		 - 	 - 
//  СтруктураКонстант		 - 	 - 
//  ЭтоИнверсивнаяИнструкция - 	 - 
// 
// Возвращаемое значение:
//   - 
//
&НаКлиентеНаСервереБезКонтекста
Функция Конкатенация2(ЧтениеДанных, Инструкция, ТипИнструкции, СтрокаКонкатенации, Перерождение, ФлагиРежима, ПозицияБифуркации, СтруктураКонстант, ЭтоИнверсивнаяИнструкция=Ложь)		
	
	Условие = Ложь;
	Если ТипИнструкции = Тип("Строка") Тогда
		ДлинаИнструкции = СтрДлина(Инструкция);
		///Здесь нужно проверить на разделители по КонвертируемыйРазделительСтрок.
		СледующиеСимволы = ЧтениеДанных.ПрочитатьСимволы(ДлинаИнструкции);
		Если ФлагиРежима.CaseInsensitive Тогда
			///Можно попробовать через СтрСравнить.
			///Есть коллизии по регистрам. Суррогатные пары(но вроде как только в UTF16/UTF16BE/UTF16LE). Один ко многим. Из-за этого нужно что-то делать по длине считываемого слова.
			Условие = (НРег(СледующиеСимволы) = НРег(Инструкция));
		Иначе
			Условие = (СледующиеСимволы = Инструкция);
		КонецЕсли;    
	ИначеЕсли ТипИнструкции = Тип("Структура") И НЕ ЭтоИнверсивнаяИнструкция Тогда
		///Нужно смотреть какой результат на нативных регулярках
		///
		///Теоретически можно сделать намного быстрее, если сделать массив Соответствий,
		///в котором ключ будет СтрДлина(Значение), а значение - символ или несколько(при коллизии преобразования регистра или составном символе):
		///и тогда мы зная сколько символов нам читать в строке можем молниеносно получать из соответствия и сравнивать
		///но мы тогда потеряем совместимость с быстрым поиском литералов и усложним парсинг выражения. Поэтому пока отложим.
		///Хотя возможность реализовать есть.
		Если Инструкция.ИЛИ.Количество() Тогда
			Если Инструкция.Медленно Тогда	
				ДлинаПредыдущегоЭлемента = 0;
				Для Каждого Элемент Из Инструкция.ИЛИ Цикл
					///Нужно сортировать перед употреблением. Максимальные по длине элементы должны быть вначале.
					ДлинаЭлемента = СтрДлина(Элемент);
					Если (НЕ ДлинаПредыдущегоЭлемента = 0) И (НЕ ДлинаПредыдущегоЭлемента = ДлинаЭлемента) Тогда
						РазмерОтката = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() - ПозицияБифуркации;
						ПотокЧтения = ЧтениеДанных.ИсходныйПоток();
						ЧтениеДанных.Закрыть();
						ПотокЧтения.Перейти(-РазмерОтката, ПозицияВПотоке.Текущая);
						ЧтениеДанных = Новый ЧтениеДанных(ПотокЧтения, КодировкаТекста.UTF8);
						ЧтениеДанных.РазделительСтрок = (Символы.ПС);
						ЧтениеДанных.КонвертируемыйРазделительСтрок = (Символы.ПС);
					
						СледующиеСимволы = ЧтениеДанных.ПрочитатьСимволы(ДлинаЭлемента);
						Условие = (СледующиеСимволы = Элемент);
						ДлинаПредыдущегоЭлемента = ДлинаЭлемента;
					ИначеЕсли ДлинаПредыдущегоЭлемента = 0 И (НЕ ДлинаПредыдущегоЭлемента = ДлинаЭлемента) Тогда
						СледующиеСимволы = ЧтениеДанных.ПрочитатьСимволы(ДлинаЭлемента);
						Условие = (СледующиеСимволы = Элемент);
						ДлинаПредыдущегоЭлемента = ДлинаЭлемента;
					Иначе
						Условие = (СледующиеСимволы = Элемент);
						ДлинаПредыдущегоЭлемента = ДлинаЭлемента;
					КонецЕсли;
					Если Условие Тогда
						Прервать;
					КонецЕсли;	
				КонецЦикла;
			Иначе
			    СледующиеСимволы = ЧтениеДанных.ПрочитатьСимволы(Инструкция.СтрДлина);
				Условие = НЕ (Инструкция.ИЛИ.Найти(СледующиеСимволы)=Неопределено);
			КонецЕсли;
	КонецЕсли;
	Если НЕ Условие Тогда
		Если Инструкция.НЕИЛИ.Количество() Тогда
			Если ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() - ПозицияБифуркации = 0 Тогда
				СледующиеСимволы = ЧтениеДанных.ПрочитатьСимволы(1);
			КонецЕсли;
			Условие = Инструкция.НЕИЛИ[СледующиеСимволы]=Неопределено;
		ИначеЕсли Инструкция.НЕИЛИ.Количество() = 0 И Инструкция.ИЛИ.Количество() = 0 Тогда
			///любой символ нужно смотреть не поймает ли ""
			СледующиеСимволы = ЧтениеДанных.ПрочитатьСимволы(1);
			Условие = Истина;
		Иначе
			///Условие = Ложь;
		КонецЕсли;
	КонецЕсли;	
	ИначеЕсли ТипИнструкции = Тип("Структура") И ЭтоИнверсивнаяИнструкция Тогда
		Если Инструкция.Медленно Тогда
			Для Каждого Элемент Из Инструкция.ИЛИ Цикл
				///Нужно сортировать перед употреблением. Максимальные по длине элементы должны быть вначале.
				ДлинаЭлемента = СтрДлина(Элемент);
				СледующиеСимволы = Сред(СтрокаКонкатенации, ПозицияБифуркации, ДлинаЭлемента);	
				Условие = Элемент=СледующиеСимволы;
				Если Условие Тогда
					Прервать;
				КонецЕсли;	
			КонецЦикла;
		Иначе
			СледующиеСимволы = Сред(СтрокаКонкатенации, ПозицияБифуркации, Инструкция.СтрДлина);
			Условие = НЕ (Инструкция.ИЛИ.Найти(СледующиеСимволы)=Неопределено);
		КонецЕсли;
		Если НЕ Условие Тогда
			Если Инструкция.НЕИЛИ.Количество() Тогда
				///Это не следующие, а предыдущие
				СледующиеСимволы = Сред(СтрокаКонкатенации, ПозицияБифуркации, 1);	
				Условие = Инструкция.НЕИЛИ[СледующиеСимволы]=Неопределено;
			ИначеЕсли Инструкция.НЕИЛИ.Количество() = 0 И Инструкция.ИЛИ.Количество() = 0 Тогда
				СледующиеСимволы = Сред(СтрокаКонкатенации, ПозицияБифуркации, 1);
				Если НЕ СледующиеСимволы = "" Тогда
					Условие = Истина;
				КонецЕсли;
			Иначе
				///Условие = Ложь;
			КонецЕсли;
		КонецЕсли;
	Иначе	
		ВызватьИсключение("Инструкция не поддерживается!");
	КонецЕсли;
	
	///Флаг перерождения обозначает тупик в поиске.
	///Переписать. Вложенность условий...
	Если НЕ Условие Тогда
		Если НЕ ЭтоИнверсивнаяИнструкция Тогда
			СтрокаКонкатенации = СтрокаКонкатенации + СледующиеСимволы;
			РазмерОтката = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() - ПозицияБифуркации;
			ПотокЧтения = ЧтениеДанных.ИсходныйПоток();
			ЧтениеДанных.Закрыть();
			ПотокЧтения.Перейти(-РазмерОтката, ПозицияВПотоке.Текущая);
			ЧтениеДанных = Новый ЧтениеДанных(ПотокЧтения, КодировкаТекста.UTF8);
			ЧтениеДанных.РазделительСтрок = (Символы.ПС);
			ЧтениеДанных.КонвертируемыйРазделительСтрок = (Символы.ПС);
		КонецЕсли;
		Перерождение = Истина;
	Иначе
		Если НЕ ЭтоИнверсивнаяИнструкция Тогда
			СтрокаКонкатенации = СтрокаКонкатенации + СледующиеСимволы;	
		КонецЕсли;
	КонецЕсли;
	
	Если ЭтоИнверсивнаяИнструкция Тогда
		Возврат СледующиеСимволы;
	Иначе
		Возврат СтрокаКонкатенации;
	КонецЕсли;
	
КонецФункции // Конкатенация()

// Функция - Вернуть варианты префиксов РН
//
// Параметры:
//  СтрокаМассивИлиКлючиСоответствия - 	 - 
// 
// Возвращаемое значение:
//   - 
//
&НаКлиентеНаСервереБезКонтекста
Функция ВернутьВариантыПрефиксовРН(СтрокаМассивИлиКлючиСоответствия)
	
	///Можно переписать на рекурсию. Но пока остановлюсь как есть на генерации пентад.
	///Может в миллионах итерациях буфер вместо строки в массиве Результат будет быстрее. Нужно замерять.
	
	КоллекцияСтрок = Новый Массив;
	Если ТипЗнч(СтрокаМассивИлиКлючиСоответствия) = Тип("Строка") Тогда
		КоллекцияСтрок.Добавить(СтрокаМассивИлиКлючиСоответствия);	
	ИначеЕсли ТипЗнч(СтрокаМассивИлиКлючиСоответствия) = Тип("Массив") ИЛИ ТипЗнч(СтрокаМассивИлиКлючиСоответствия) = Тип("Соответствие") Тогда
		Если НЕ СтрокаМассивИлиКлючиСоответствия.Количество() Тогда
			ВызватьИсключение("Массив параметра пуст!");
		Иначе
			КоллекцияСтрок = СтрокаМассивИлиКлючиСоответствия;
		КонецЕсли;
	Иначе
		ВызватьИсключение("Неожиданный тип входного параметра!");	
	КонецЕсли;
	
	ЭтоСоответствие = Ложь;	
	Если ТипЗнч(КоллекцияСтрок) = Тип("Соответствие") Тогда
		Результат = Новый Соответствие;
		ЭтоСоответствие = Истина;
	Иначе
		Результат = Новый Массив;
	КонецЕсли;
	
	Для Каждого Элемент Из КоллекцияСтрок Цикл
		Если ТипЗнч(СтрокаМассивИлиКлючиСоответствия) = Тип("Соответствие") Тогда
			Элемент = Элемент.Ключ;
		КонецЕсли;
		Строка = НРег(Элемент);
		ПодстрокаРазбора = Сред(Строка, 1, 5);
		ДлинаПодстроки = СтрДлина(ПодстрокаРазбора);
		Для Символ=0 По 1 Цикл
			Для Пара=0 По 1 Цикл
				Для Триада = 0 По 1 Цикл
					Для Тетрада = 0 По 1 Цикл
						Для Пентада = 0 По 1 Цикл
							Если ДлинаПодстроки = 5 Тогда
								Если Булево(Пентада) Тогда
									Результат5Пентада = ВРег(Сред(ПодстрокаРазбора, 5, 1)); 	
								Иначе 
									Результат5Пентада = НРег(Сред(ПодстрокаРазбора, 5, 1));
								КонецЕсли;
								
								Если Булево(Тетрада) Тогда
									Результат4Пентада = ВРег(Сред(ПодстрокаРазбора, 4, 1));
								Иначе 
									Результат4Пентада = НРег(Сред(ПодстрокаРазбора, 4, 1));
								КонецЕсли;
								
								Если Булево(Триада) Тогда
									Результат3Пентада = ВРег(Сред(ПодстрокаРазбора, 3, 1));
								Иначе 
									Результат3Пентада = НРег(Сред(ПодстрокаРазбора, 3, 1));
								КонецЕсли;
								
								Если Булево(Пара) Тогда
									Результат2Пентада = ВРег(Сред(ПодстрокаРазбора, 2, 1));
								Иначе 
									Результат2Пентада = НРег(Сред(ПодстрокаРазбора, 2, 1));
								КонецЕсли;
								
								Если Булево(Символ) Тогда
									Результат1Пентада = ВРег(Сред(ПодстрокаРазбора, 1, 1));
								Иначе 
									Результат1Пентада = НРег(Сред(ПодстрокаРазбора, 1, 1));
								КонецЕсли;
								
								РезультатПентада = Результат1Пентада + Результат2Пентада + Результат3Пентада + Результат4Пентада + Результат5Пентада;
								Если НЕ ЭтоСоответствие Тогда 
									Если Результат.Количество() Тогда
										Если Результат.Найти(РезультатПентада) = Неопределено Тогда
											Результат.Добавить(РезультатПентада);
										КонецЕсли;
									Иначе
										Результат.Добавить(РезультатПентада);
									КонецЕсли;
								Иначе
									Если Результат.Количество() Тогда
										Если Результат[РезультатПентада] = Неопределено Тогда
											Результат.Вставить(РезультатПентада, Ложь);
										КонецЕсли;
									Иначе
										Результат.Вставить(РезультатПентада, Ложь);
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;	
						КонецЦикла;
						Если ДлинаПодстроки = 4 Тогда
							Если Булево(Тетрада) Тогда
								Результат4Тетрада = ВРег(Сред(ПодстрокаРазбора, 4, 1)); 	
							Иначе 
								Результат4Тетрада = НРег(Сред(ПодстрокаРазбора, 4, 1));
							КонецЕсли;
							
							Если Булево(Триада) Тогда
								Результат3Тетрада = ВРег(Сред(ПодстрокаРазбора, 3, 1));
							Иначе 
								Результат3Тетрада = НРег(Сред(ПодстрокаРазбора, 3, 1));
							КонецЕсли;
							
							Если Булево(Пара) Тогда
								Результат2Тетрада = ВРег(Сред(ПодстрокаРазбора, 2, 1));
							Иначе 
								Результат2Тетрада = НРег(Сред(ПодстрокаРазбора, 2, 1));
							КонецЕсли;
							
							Если Булево(Символ) Тогда
								Результат1Тетрада = ВРег(Сред(ПодстрокаРазбора, 1, 1));
							Иначе 
								Результат1Тетрада = НРег(Сред(ПодстрокаРазбора, 1, 1));
							КонецЕсли;
							
							РезультатТетрада = Результат1Тетрада + Результат2Тетрада + Результат3Тетрада + Результат4Тетрада;
							Если НЕ ЭтоСоответствие Тогда 
								Если Результат.Количество() Тогда
									Если Результат.Найти(РезультатТетрада) = Неопределено Тогда
										Результат.Добавить(РезультатТетрада);
									КонецЕсли;
								Иначе
									Результат.Добавить(РезультатТетрада);
								КонецЕсли;
							Иначе
								Если Результат.Количество() Тогда
									Если Результат[РезультатТетрада] = Неопределено Тогда
										Результат.Вставить(РезультатТетрада, Ложь);
									КонецЕсли;
								Иначе
									Результат.Вставить(РезультатТетрада, Ложь);
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
					Если ДлинаПодстроки = 3 Тогда
						Если Булево(Триада) Тогда
							Результат3Триада = ВРег(Сред(ПодстрокаРазбора, 3, 1)); 	
						Иначе 
							Результат3Триада = НРег(Сред(ПодстрокаРазбора, 3, 1));
						КонецЕсли;
						
						Если Булево(Пара) Тогда
							Результат2Триада = ВРег(Сред(ПодстрокаРазбора, 2, 1));
						Иначе 
							Результат2Триада = НРег(Сред(ПодстрокаРазбора, 2, 1));
						КонецЕсли;
						
						Если Булево(Символ) Тогда
							Результат1Триада = ВРег(Сред(ПодстрокаРазбора, 1, 1));
						Иначе 
							Результат1Триада = НРег(Сред(ПодстрокаРазбора, 1, 1));
						КонецЕсли;
						РезультатТриада = Результат1Триада + Результат2Триада + Результат3Триада;
						Если НЕ ЭтоСоответствие Тогда 
							Если Результат.Количество() Тогда
								Если Результат.Найти(РезультатТриада) = Неопределено Тогда
									Результат.Добавить(РезультатТриада);
								КонецЕсли;
							Иначе
								Результат.Добавить(РезультатТриада);
							КонецЕсли;
						Иначе
							Если Результат.Количество() Тогда
								Если Результат[РезультатТриада] = Неопределено Тогда
									Результат.Вставить(РезультатТриада, Ложь);
								КонецЕсли;
							Иначе
								Результат.Вставить(РезультатТриада, Ложь);
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				Если ДлинаПодстроки = 2 Тогда
					Если Булево(Пара) Тогда
						Результат2Пара = ВРег(Сред(ПодстрокаРазбора, 2, 1)); 	
					Иначе 
						Результат2Пара = НРег(Сред(ПодстрокаРазбора, 2, 1));
					КонецЕсли;
					
					Если Булево(Символ) Тогда
						Результат1Пара = ВРег(Сред(ПодстрокаРазбора, 1, 1));
					Иначе 
						Результат1Пара = НРег(Сред(ПодстрокаРазбора, 1, 1));
					КонецЕсли;				
					РезультатПара = Результат1Пара + Результат2Пара;
					Если НЕ ЭтоСоответствие Тогда 
						Если Результат.Количество() Тогда
							Если Результат.Найти(РезультатПара) = Неопределено Тогда
								Результат.Добавить(РезультатПара);
							КонецЕсли;
						Иначе
							Результат.Добавить(РезультатПара);
						КонецЕсли;
					Иначе
						Если Результат.Количество() Тогда
							Если Результат[РезультатПара] = Неопределено Тогда
								Результат.Вставить(РезультатПара, Ложь);
							КонецЕсли;
						Иначе
							Результат.Вставить(РезультатПара, Ложь);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;	
			КонецЦикла;
			Если ДлинаПодстроки = 1 Тогда
				Если Булево(Символ) Тогда
					РезультатСимвол = ВРег(ПодстрокаРазбора);
				Иначе 
					РезультатСимвол = НРег(ПодстрокаРазбора);
				КонецЕсли;
				Если НЕ ЭтоСоответствие Тогда 
					Если Результат.Количество() Тогда
						Если Результат.Найти(РезультатСимвол) = Неопределено Тогда
							Результат.Добавить(РезультатСимвол);
						КонецЕсли;
					Иначе
						Результат.Добавить(РезультатСимвол);
					КонецЕсли;
				Иначе
					Если Результат.Количество() Тогда
						Если Результат[РезультатСимвол] = Неопределено Тогда
							Результат.Вставить(РезультатСимвол, Ложь);
						КонецЕсли;
					Иначе
						Результат.Вставить(РезультатСимвол, Ложь);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ВариантыРегистровСтроки()

// Функция - Разобрать диапазон по структуре
//
// Параметры:
//  Структура	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
&НаКлиентеНаСервереБезКонтекста
Функция РазобратьДиапазонПоСтруктуре(Структура)

	Если НЕ (Структура.Свойство("Инверсивный") И Структура.Свойство("Значения")) Тогда
		ВызватьИсключение("Свойства структуры диапазона не соответствуют шаблону.");
	ИначеЕсли НЕ ТипЗнч(Структура.Значения) = Тип("ФиксированныйМассив") Тогда
		ВызватьИсключение("Неожиданный тип свойства Значения!");
	ИначеЕсли НЕ Структура.Значения.Количество() Тогда
		ВызватьИсключение("Массив значений пуст!");	
	ИначеЕсли НЕ Структура.Значения.Количество()%2=0 Тогда
		ВызватьИсключение("Ошибка парности значений диапазонов!");	
	КонецЕсли;
	
	МассивЗначений = Структура.значения;
	Граница = МассивЗначений.ВГраница();
	МассивРезультат = Новый Массив;
	
	Шаг = 2;
	Для Итератор = 0 По Граница Цикл
		Начало = МассивЗначений[Итератор];
		Окончание = МассивЗначений[Итератор + 1];
		Для КодСимв = Начало По Окончание Цикл
			МассивРезультат.Добавить(Символ(КодСимв));	
		КонецЦикла;
		Итератор = Итератор + Шаг - 1;
	КонецЦикла;
	
	Если Структура.Инверсивный Тогда
		СоответствиеРезультат = Новый Соответствие;
		Для Каждого Элемент Из МассивРезультат Цикл
			СоответствиеРезультат.Вставить(Элемент, Ложь);	
		КонецЦикла;
		Результат = СоответствиеРезультат;
	Иначе	
		Результат = МассивРезультат;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьМассивДиапазонаПоСтруктуре()

// Процедура - На сервере2 на сервере
//
// Параметры:
//  Паттерн		 - 	 - 
//  ФлагиРежима	 - 	 - 
//
&НаСервереБезКонтекста
Процедура НаСервере2НаСервере(Паттерн, ФлагиРежима, ЗНАЧ ОбрабатываемаяСтрока, ПутьКФайлу)
	
	ЗапускАвтомата(Паттерн, ФлагиРежима, ОбрабатываемаяСтрока, ПутьКФайлу);
	
КонецПроцедуры

// Процедура - На сервере2
//
// Параметры:
//  Команда	 - 	 - 
//
&НаКлиенте
Процедура НаСервере2(Команда)
	
	ОчиститьСообщения();
	ФлагиРежима = Новый Структура("Global, CaseInsensitive, Multiline, Singleline, Unicode", Объект.Global, Объект.CaseInsensitive, Объект.Multiline, Объект.Singleline, Объект.Unicode);
	НаСервере2НаСервере(Объект.Паттерн, ФлагиРежима, Объект.ОбрабатываемаяСтрока, ПутьКФайлуНаСервере);
	
КонецПроцедуры

// Процедура - Обрабатываемая строка при изменении
//
// Параметры:
//  Элемент	 - 	 - 
//
&НаКлиенте
Процедура ОбрабатываемаяСтрокаПриИзменении(Элемент)
	
	ПутьКФайлуНаСервере = "";
	Элементы.ПутьКФайлуНаСервере.Доступность = Объект.ОбрабатываемаяСтрока="";
	
КонецПроцедуры

// Процедура - Путь к файлу на сервере при изменении
//
// Параметры:
//  Элемент	 - 	 - 
//
&НаКлиенте
Процедура ПутьКФайлуНаСервереПриИзменении(Элемент)
	
	Объект.ОбрабатываемаяСтрока = "";
	Элементы.ОбрабатываемаяСтрока.Доступность = ПутьКФайлуНаСервере="";
	
КонецПроцедуры

#КонецОбласти
